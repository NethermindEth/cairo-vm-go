"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[731],{3905:(e,t,i)=>{i.d(t,{Zo:()=>u,kt:()=>h});var n=i(7294);function o(e,t,i){return t in e?Object.defineProperty(e,t,{value:i,enumerable:!0,configurable:!0,writable:!0}):e[t]=i,e}function r(e,t){var i=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),i.push.apply(i,n)}return i}function a(e){for(var t=1;t<arguments.length;t++){var i=null!=arguments[t]?arguments[t]:{};t%2?r(Object(i),!0).forEach((function(t){o(e,t,i[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(i)):r(Object(i)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(i,t))}))}return e}function s(e,t){if(null==e)return{};var i,n,o=function(e,t){if(null==e)return{};var i,n,o={},r=Object.keys(e);for(n=0;n<r.length;n++)i=r[n],t.indexOf(i)>=0||(o[i]=e[i]);return o}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(n=0;n<r.length;n++)i=r[n],t.indexOf(i)>=0||Object.prototype.propertyIsEnumerable.call(e,i)&&(o[i]=e[i])}return o}var l=n.createContext({}),c=function(e){var t=n.useContext(l),i=t;return e&&(i="function"==typeof e?e(t):a(a({},t),e)),i},u=function(e){var t=c(e.components);return n.createElement(l.Provider,{value:t},e.children)},d="mdxType",m={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},p=n.forwardRef((function(e,t){var i=e.components,o=e.mdxType,r=e.originalType,l=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),d=c(i),p=o,h=d["".concat(l,".").concat(p)]||d[p]||m[p]||r;return i?n.createElement(h,a(a({ref:t},u),{},{components:i})):n.createElement(h,a({ref:t},u))}));function h(e,t){var i=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var r=i.length,a=new Array(r);a[0]=p;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[d]="string"==typeof e?e:o,a[1]=s;for(var c=2;c<r;c++)a[c]=i[c];return n.createElement.apply(null,a)}return n.createElement.apply(null,i)}p.displayName="MDXCreateElement"},4225:(e,t,i)=>{i.r(t),i.d(t,{assets:()=>l,contentTitle:()=>a,default:()=>m,frontMatter:()=>r,metadata:()=>s,toc:()=>c});var n=i(7462),o=(i(7294),i(3905));const r={sidebar_position:-1},a="Introduction to the Cairo Virtual Machine",s={unversionedId:"vm-fundamentals/intro",id:"vm-fundamentals/intro",title:"Introduction to the Cairo Virtual Machine",description:"Welcome to the documentation for the Cairo VM.",source:"@site/docs/vm-fundamentals/intro.md",sourceDirName:"vm-fundamentals",slug:"/vm-fundamentals/intro",permalink:"/docs/vm-fundamentals/intro",draft:!1,editUrl:"https://github.com/NethermindEth/cairo-vm-go/tree/main/docs/docs/vm-fundamentals/intro.md",tags:[],version:"current",sidebarPosition:-1,frontMatter:{sidebar_position:-1},sidebar:"tutorialSidebar",previous:{title:"VM - Fundamentals",permalink:"/docs/category/vm---fundamentals"},next:{title:"Layout",permalink:"/docs/vm-fundamentals/layout"}},l={},c=[{value:"VM Layout",id:"vm-layout",level:2},{value:"Registers",id:"registers",level:3},{value:"Pointers",id:"pointers",level:3},{value:"Memory",id:"memory",level:3},{value:"Basic Instructions",id:"basic-instructions",level:2},{value:"Assert Statements",id:"assert-statements",level:3},{value:"Pointer Management",id:"pointer-management",level:3},{value:"Control Flow Instructions",id:"control-flow-instructions",level:3},{value:"<code>Cal</code>\xa0and\xa0<code>Ret</code>\xa0for Call and Return",id:"calandretfor-call-and-return",level:3},{value:"Advanced Syntax and Operations",id:"advanced-syntax-and-operations",level:3},{value:"Builtins",id:"builtins",level:2},{value:"Hints",id:"hints",level:2},{value:"Cairo Runner",id:"cairo-runner",level:2},{value:"Resources",id:"resources",level:2}],u={toc:c},d="wrapper";function m(e){let{components:t,...i}=e;return(0,o.kt)(d,(0,n.Z)({},u,i,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"introduction-to-the-cairo-virtual-machine"},"Introduction to the Cairo Virtual Machine"),(0,o.kt)("p",null,"Welcome to the documentation for the Cairo VM. "),(0,o.kt)("p",null,"First, let us clarify what is a Virtual Machine (VM)? A VM is\xa0",(0,o.kt)("strong",{parentName:"p"},"a digital version of a physical computer,")," that can run programs and operating systems, store data, connect to networks, and do other computing functions."),(0,o.kt)("p",null,"This documentation is designed to provide developers with a fundamental understanding of the Cairo VM's architecture and capabilities, empowering them to build and optimize applications on Starknet effectively. This documentation will be divided into four main parts, each of which we will briefly describe in this introduction."),(0,o.kt)("p",null,"The Cairo Virtual Machine (CVM), at the heart of the Starknet network, is an advanced computational framework specifically designed to execute\xa0Casm\xa0bytecode generated by the Cairo compiler. Also, the Cairo VM is able to generate cryptographic proofs, these proofs will be posted on a settlement layer such as Ethereum, offering Starknet the same level of security as the underlying layer."),(0,o.kt)("h2",{id:"vm-layout"},"VM Layout"),(0,o.kt)("p",null,"The Cairo Virtual Machine optimizes its operations around a unique structure of registers and memory to facilitate the efficient execution of Casm bytecode. "),(0,o.kt)("h3",{id:"registers"},"Registers"),(0,o.kt)("p",null,"Unlike traditional architectures where registers are separate storage units, in Cairo, these registers are pointers that facilitate access and management of memory during program execution."),(0,o.kt)("p",null,"General-Purpose Registers: These are hypothetical in Cairo, where instead of traditional CPU-bound registers all operations are directly performed on memory cells. This approach aligns with Cairo\u2019s optimization strategy which aims to minimize the number of trace cells in the Algebraic Intermediate Representation (AIR). In Cairo, registers such as the Program Counter (pc), Allocation Pointer (ap), and Frame Pointer (fp) do not store data themselves."),(0,o.kt)("h3",{id:"pointers"},"Pointers"),(0,o.kt)("p",null,"Program Counter (pc) points to the current instruction in memory that the VM is executing.\nAllocation Pointer (ap) identifies the first free memory cell not yet used by the program, crucial for dynamic memory management. Frame Pointer (fp) points to the beginning of the stack frame of the current function, managing the execution context of function calls."),(0,o.kt)("h3",{id:"memory"},"Memory"),(0,o.kt)("p",null,"Cairo employs a nondeterministic read-only memory model. Unlike typical random-access memory (RAM) used in most computing systems where any memory cell can be read or written at any time, Cairo's memory model only allows memory to be written once and restricts subsequent modifications. In addition, this memory model is particularly efficient for proof generation, as it requires fewer trace cells per memory access."),(0,o.kt)("p",null,"Cairo's memory model also introduces the idea of \"public memory,\" a crucial feature for validating data integrity between the prover and verifier. This feature enables the prover to prove that specific memory cells contain certain values without exposing the entire memory's content. "),(0,o.kt)("p",null,"This feature is crucial for operations like loading bytecode, passing arguments, and returning values from programs because it ensures data integrity and security. By proving that specific memory cells contain certain values without exposing the entire memory's content, it prevents unauthorized access to data and protects against data manipulation. Additionally, it increases efficiency as it allows the Cairo VM to directly access required data instead of scanning through the entire memory."),(0,o.kt)("h2",{id:"basic-instructions"},"Basic Instructions"),(0,o.kt)("p",null,"Cairo's instruction set is designed to facilitate the verification of computations within its unique programming environment. The foundational aspect of Cairo instructions revolves around assertions of equality, which form the basis of most operations within the virtual machine."),(0,o.kt)("h3",{id:"assert-statements"},"Assert Statements"),(0,o.kt)("p",null,"A primary form of instruction in Cairo is the assert statement, which verifies that two values or computations are equal. For example, the instruction ",(0,o.kt)("inlineCode",{parentName:"p"},"[ap] = [ap - 1] * [fp], ap++"),"; not only performs multiplication but also asserts that the result is equal to the value at the current free memory cell\xa0",(0,o.kt)("inlineCode",{parentName:"p"},"[ap]"),", before incrementing\xa0",(0,o.kt)("inlineCode",{parentName:"p"},"[ap]"),"\xa0with\xa0",(0,o.kt)("inlineCode",{parentName:"p"},"ap++"),". "),(0,o.kt)("h3",{id:"pointer-management"},"Pointer Management"),(0,o.kt)("p",null,"The increment of the allocation pointer (ap++) is an important standalone operation in many Cairo instructions. It prepares the virtual machine to utilize the next cell in memory for future operations, thereby ensuring a seamless flow of computation."),(0,o.kt)("h3",{id:"control-flow-instructions"},"Control Flow Instructions"),(0,o.kt)("p",null,"Conditional and Unconditional Jumps: These instructions manage the flow of execution, allowing the program to branch or loop based on conditions or unconditionally, respectively."),(0,o.kt)("h3",{id:"calandretfor-call-and-return"},(0,o.kt)("inlineCode",{parentName:"h3"},"Cal"),"\xa0and\xa0",(0,o.kt)("inlineCode",{parentName:"h3"},"Ret"),"\xa0for Call and Return"),(0,o.kt)("p",null,"Similar to functions in traditional programming, these instructions manage the execution of subroutines within Cairo code. The call instruction directs the machine to execute a block of code at another location, and return concludes that execution, resuming control at the point following the original call.\nThese control structures are pivotal for creating complex, logical structures within Cairo programs, enabling more dynamic and versatile applications than would be possible with linear execution paths alone."),(0,o.kt)("h3",{id:"advanced-syntax-and-operations"},"Advanced Syntax and Operations"),(0,o.kt)("p",null,"In addition to fundamental arithmetic and control flow operations, Cairo provides advanced features for greater code complexity and efficiency. It supports complex operations such as double dereferencing, which allows values to be used as memory addresses, and the direct modification of values using immediate values and offsets, which provides flexibility in memory operations."),(0,o.kt)("h2",{id:"builtins"},"Builtins"),(0,o.kt)("p",null,"Builtins in Cairo are predefined and optimized low-level execution units that are added to the Cairo CPU board to perform predefined calculations that are expensive to perform in Cairo. Communication between the CPU and embedded functionalities occurs through memory-mapped I/O. Each builtin is assigned a contiguous region of memory and applies specific restrictions on the data found in that area."),(0,o.kt)("h2",{id:"hints"},"Hints"),(0,o.kt)("p",null,'Cairo language introduces "prover hints" or simply "hints" which are snippets of code strategically inserted between Cairo instructions to facilitate additional computations necessary for the prover\'s operations. Unique to the prover\'s process, these hints can be authored in any programming language, as their execution is not required to be verified, not needed to be included in the proof submitted to the verifier. As a result, when the Cairo Runner encounters a hint before a Cairo instruction, it executes the hint first, potentially initializing memory cells before proceeding with the Cairo instruction.'),(0,o.kt)("p",null,"Hints are written in Python in the Cairo VM currently in production, providing a powerful tool for the prover to execute operations invisible to the verifier, hence, this invisibility is crucial as it allows the hint to perform complex tasks without making them part of the program's formal execution trace, thereby not counting towards the total number of execution steps in the Cairo VM. Moreover, while hints offer enhanced capabilities in writing Cairo code, their use within Starknet contracts should be avoided unless the hints are specifically approved or whitelisted by Starknet."),(0,o.kt)("p",null,'A "hint" in Cairo is a block of any language executed just before the subsequent Cairo instruction, interacting directly with the program\u2019s variables or memory. To incorporate a hint, simply write Python code inside the\xa0',(0,o.kt)("inlineCode",{parentName:"p"},"%{ ... %}"),"\xa0markers, this feature allows programmers to leverage Python's extensive functionalities within Cairo programs, enhancing their capability to manage complex computations efficiently and securely."),(0,o.kt)("p",null,"Hints in Cairo are useful when the cost of verifying a computed value is cheaper than finding the value itself, they are particularly valuable for solving equations or optimizing computational tasks. "),(0,o.kt)("h2",{id:"cairo-runner"},"Cairo Runner"),(0,o.kt)("p",null,"The Cairo Runner, a specialized computer program, executes compiled Cairo programs. Unlike conventional programs, these include nondeterministic code due to Cairo's acceptance of nondeterminism. For instance, when computing the square root of a number, the Cairo Runner considers both possible outcomes (+Y and -Y). It then selects the solution that aligns with the following program instructions."),(0,o.kt)("p",null,"The output of the Cairo Runner comprises two main parts: an accepting input for the Cairo nondeterministic machine and a corresponding input for the Cairo deterministic machine, which serves as the witness for the nondeterministic machine. Additionally, the Runner may return a failure if the execution results in a contradiction or if it cannot compute the value of a memory cell due to insufficient hints."),(0,o.kt)("p",null,'This process is supported by "hints," which are special instructions that the Cairo Runner utilizes to resolve nondeterministic outcomes that cannot be directly inferred. These hints, typically written in Python, are crucial for the execution of certain Cairo programs where additional information is necessary to determine the course of execution.'),(0,o.kt)("h2",{id:"resources"},"Resources"))}m.isMDXComponent=!0}}]);