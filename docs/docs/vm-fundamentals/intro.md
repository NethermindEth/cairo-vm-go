---
sidebar_position: -1
---

# Intro

Welcome to the introductory documentation for the Cairo VM, an essential component of the StarkNet ecosystem. This documentation is designed to provide developers with a fundamental understanding of the Cairo VM's architecture and capabilities, empowering them to build and optimize applications on StarkNet effectively.

The Cairo Virtual Machine (CVM), at the heart of the StarkNet ecosystem, is an advanced computational framework specifically designed to execute bytecode generated by the Cairo compiler. Unlike traditional virtual machines constrained by the limitations of the Ethereum Virtual Machine (EVM), the Cairo VM operates under the principles of Validity Proof systems, enhancing the scalability and security of Ethereum through STARK proofs.

## VM Layout

The Cairo Virtual Machine optimizes its operations around a unique structure of registers and memory to facilitate the efficient execution of Cairo code. A "register" typically refers to a quick-access storage area within the CPU, so the Cairo VM distinguishes between two main types of storage for executing instructions:

General-Purpose Registers: These are hypothetical in Cairo, where instead of traditional CPU-bound registers, all operations are directly performed on memory cells, in this way, this approach aligns with Cairo’s optimization strategy, which aims to minimize the number of trace cells in the Algebraic Intermediate Representation (AIR).

Memory Models: Cairo employs a nondeterministic read-only memory model, unlike typical random-access memory (RAM) used in most computing systems where any memory cell can be read or written at any time, Cairo's memory model only allows memory to be written once and restricts subsequent modifications. In addition, this model is particularly efficient for AIR, as it requires fewer trace cells per memory access, optimizing the proof generation process.

Additionally, Cairo's memory model supports the concept of "public memory," which is essential for verifying the integrity of data between the prover and verifier, likewise, public memory allows the prover to demonstrate that certain memory cells hold specific values without revealing the entire memory content. This feature is crucial for operations like loading bytecode, passing arguments, and returning values from programs, making it both a secure and efficient mechanism for handling data within the Cairo VM.

## Basic Instructions

Cairo's instruction set is designed to facilitate the verification of computations within its unique programming environment. The foundational aspect of Cairo instructions revolves around assertions of equality, which form the basis of most operations within the virtual machine.

Assert Statements:
A primary form of instruction in Cairo is the assert statement, which verifies that two values or computations are equal. For example, the instruction [ap] = [ap - 1] * [fp], ap++; not only performs multiplication but also asserts that the result is equal to the value at the next allocation pointer (ap). Furthermore, this mechanism is essential for ensuring that each step of the computation adheres to expected results, crucial for the integrity of proofs in the Cairo system.

Pointer Management:
Incrementing the allocation pointer (ap++) is a standard operation accompanying many Cairo instructions. This operation is crucial as it prepares the virtual machine to access the next cell in memory for subsequent operations, maintaining a continuous flow of computation.

Advanced Syntax and Operations:
Beyond basic arithmetic and control flow, Cairo supports advanced operations and syntactic constructs that enhance the expressiveness and functionality of the code. Instructions can involve complex operations like double dereferencing, which interprets values as addresses, and direct manipulation of values with immediate and offsets to facilitate flexible memory operations.

## Builtins

As seen at the beginning of this documentation, builtins in Cairo can be likened to adding specialized Lego pieces to a set. While regular Cairo instructions serve their purpose, builtins offer optimized, pre-built solutions for complex tasks, akin to special Lego components that snap together effortlessly. These builtins not only enhance the efficiency of Cairo programs but also streamline development by providing ready-made solutions for tasks like mathematical operations, cryptographic computations, memory management, and comparisons.

However, the integration of builtins introduces certain trade-offs and considerations. These include managing resource usage effectively to prevent performance degradation or vulnerabilities, ensuring robust security measures to mitigate risks such as integer overflow, reentrancy attacks, and access control issues, and maintaining compatibility with existing standards and protocols within the blockchain ecosystem.

In essence, while builtins offer a powerful toolset for developing efficient and secure Cairo programs, developers must carefully navigate these constraints to harness their full potential and ensure seamless integration within the broader blockchain landscape.

## Hints

Cairo language introduces "prover hints" or simply "hints" which are snippets of code strategically inserted between Cairo instructions to facilitate additional computations necessary for the prover's operations. Unique to the prover's process, these hints can be authored in any programming language, as their execution is not required to be verified, thereby not needing to be included in the proof submitted to the verifier. As a result, when the Cairo Runner encounters a hint before a Cairo instruction, it executes the hint first potentially initializing memory cells before proceeding with the Cairo instruction.

Hints are typically written in Python, providing a powerful tool for the prover to execute operations invisible to the verifier, hence, this invisibility is crucial as it allows the hint to perform complex tasks without making them part of the program's formal execution trace, thereby not counting towards the total number of execution steps in the Cairo VM. Moreover, while hints offer enhanced capabilities in writing Cairo code, it is recommended to avoid their use in Starknet contracts, unless the contract is specifically approved or whitelisted by Starknet. 

As a consequence, a "hint" in Cairo is a block of Python code executed just before the subsequent Cairo instruction, interacting directly with the program’s variables or memory. So, to incorporate a hint, the Python code must be enclosed within %{ and %} markers, this feature allows programmers to leverage Python's extensive functionalities within Cairo programs, enhancing their capability to manage complex computations efficiently and securely.

## Cairo Runner

The Cairo Runner serves as the practical interface between theoretical computational models and their execution within the Cairo framework because it is a pivotal tool in the transformation of abstract statements into verifiable computations, exemplified by converting a claim such as "the j-th Fibonacci number is y" into inputs that the deterministic and nondeterministic Cairo machines can process. The success of these inputs in the respective machines substantiates the truth of the original statement, leveraging the Cairo AIR and the STARK protocol to demonstrate the validity of these computations.

As a specialized computer program, the Cairo Runner is responsible for executing compiled Cairo programs, which notably include nondeterministic code, this execution is distinct from that of conventional programs due to Cairo's allowance for nondeterminism. For example, in a scenario where the computation involves finding the square root of a number, the Cairo Runner facilitates the execution by considering both possible solutions (e.g., +Y and -Y) and selecting the one that satisfies the subsequent program instructions.

This process is supported by "hints," which are special instructions that the Cairo Runner utilizes to resolve nondeterministic outcomes that cannot be directly inferred. These hints, typically written in Python, are crucial for the execution of certain Cairo programs where additional information is necessary to determine the course of execution.

## Resources

In the Cairo Virtual Machine, state transitions, influenced by each instruction, play a crucial role in the VM's operation. Unlike traditional deterministic CPU architectures, Cairo can handle nondeterministic transitions, allowing it to verify a wider range of computational statements efficiently. However, if a valid subsequent state cannot be established leading to what's known as an "execution rejection" the prover cannot generate proof for that program's execution. Therefore, this highlights the importance of stringent resource management within Cairo, ensuring that the VM operates within its limits and maintains the overall stability and security of the StarkNet platform.

Managing resources effectively is essential for preventing scenarios where an execution might be rejected due to the system hitting resource limits or encountering computationally infeasible states. By carefully monitoring and constraining the use of memory, computational steps, and data outputs, the Cairo VM ensures that each program can be executed and verified without risking the overall stability and security of the StarkNet platform.
